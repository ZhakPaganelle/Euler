##Randomized Binary Search

A secret integer t is selected at random within the range 1 ≤ t ≤ n. 
The goal is to guess the value of t by making repeated guesses, via integer g. After a guess is made, there are three possible outcomes, in which it will be revealed that either g < t, g = t, or g > t. Then the process can repeat as necessary.
Normally, the number of guesses required on average can be minimized with a binary search: Given a lower bound L and upper bound H (initialized to L = 1 and H = n), let g = ⌊(L+H)/2⌋ where ⌊⋅⌋ is the integer floor function. If g = t, the process ends. Otherwise, if g < t, set L = g+1, but if g > t instead, set H = g−1. After setting the new bounds, the search process repeats, and ultimately ends once t is found. Even if t can be deduced without searching, assume that a search will be required anyway to confirm the value.
Your friend Bob believes that the standard binary search is not that much better than his randomized variant: Instead of setting g = ⌊(L+H)/2⌋, simply let g be a random integer between L and H, inclusive. The rest of the algorithm is the same as the standard binary search. This new search routine will be referred to as a random binary search.
Given that 1 ≤ t ≤ n for random t, let B(n) be the expected number of guesses needed to find t using the standard binary search, and let R(n) be the expected number of guesses needed to find t using the random binary search. For example, B(6) = 2.33333333 and R(6) = 2.71666667 when rounded to 8 decimal places.
Find R(1010) − B(1010) rounded to 8 decimal places.
##Случайный двоичный поиск

Секретное целое число t выбирается случайно в интервале 1 ≤ t ≤ n. 
Цель - угадать значение t, делая многократные проверки с помощью целого числа g. После проверки догадки есть три возможных ситуации, в которых выяснится, что g < t, g = t или g > t. При необходимости процесс повторяется.
Обычно, необходимое среднее количество попыток может быть минимизированно с помощью двоичного поиска: при данной нижней границе L и верхней границей H (начальные значения L = 1 и H = n), пусть g = $\lfloor (L+H)/2 \rfloor$, где $\lfloor \rfloor$ - функция целого пола числа. Если g = t, процесс завершается. В противном случае, если g < t, задать L = g+1, а если g > t, задать H = g−1. После задания новых границ процесс поиска повторяется, и, в конце концов, завершается, когда t найдена. Даже если t может быть выведена без применения поиска, положим, что поиск все равно будет необходим, чтобы доказать значение.
Ваш друг Боб уверен, что стандартный двоичный поиск не намного лучше его рандомизированного варианта: вместо задания g = $\lfloor (L+H)/2 \rfloor$, g просто задается случайным целым числом между L и H включительно. Остальной алгоритм таков же, как в стандартном двоичном поиске. Этот новый метод поиска назовем случайным двоичным поиском.
Дано, что 1 ≤ t ≤ n для случайного t. Пусть B(n) будет ожидаемым количеством попыток, необходимых для нахождения t с помощью стандартного двоичного поиска, и пусть R(n) будет ожидаемым количеством попыток, необходимых для нахождения t с помощью случайного двоичного поиска. Например, B(6) = 2.33333333 и R(6) = 2.71666667 при округлении до 8 знака после десятичной точки.
Найдите R(1010) − B(1010), округленное до 8 знака после десятичной точки.
